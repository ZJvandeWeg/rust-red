use crate::*;

pub struct ContextStoreProperty<'a> {
    pub store: &'a str,
    pub key: &'a str,
}

fn context_store_parser(
    input: &str,
) -> nom::IResult<&str, ContextStoreProperty<'_>, nom::error::VerboseError<&str>> {
    use crate::text::nom_parsers::*;
    use nom::{
        bytes::complete::tag,
        character::complete::{char, multispace0},
        combinator::rest,
        sequence::delimited,
    };

    let (input, _) = tag("#:")(input)?;

    let (input, store) = delimited(
        char('('),
        delimited(multispace0, identifier, multispace0),
        char(')'),
    )(input)?;

    let (input, _) = tag("::")(input)?;
    let (input, key) = rest(input)?;

    Ok((input, ContextStoreProperty { store, key }))
}

/// Parses a context property string, as generated by the TypedInput, to extract
/// the store name if present.
///
/// # Examples
/// For example, `#:(file)::foo.bar` results in ` ParsedContextStoreProperty{ store: "file", key: "foo.bar" }`.
/// ```
/// use edgelink_core::runtime::eval::parse_context_store;
///
/// let res = parse_context_store("#:(file)::foo.bar").unwrap();
/// assert_eq!("file", res.store);
/// assert_eq!("foo.bar", res.key);
/// ```
/// @param  {String} key - the context property string to parse
/// @return {Object} The parsed property
/// @memberof @node-red/util_util
pub fn parse_context_store(key: &str) -> crate::Result<ContextStoreProperty<'_>> {
    match context_store_parser(key) {
        Ok(res) => Ok(res.1),
        Err(e) => Err(EdgelinkError::BadArguments(
            format!("Can not parse the key: '{0}'", e).to_owned(),
        )
        .into()),
    }
}
